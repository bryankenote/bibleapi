// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: verses.sql

package sqlc

import (
	"context"
)

const createVerse = `-- name: CreateVerse :one
INSERT INTO verses (
	translation, book, chapter, verse, content
) VALUES (
	?, ?, ?, ?, ?
)
RETURNING id, translation, book, chapter, verse, content
`

type CreateVerseParams struct {
	Translation string
	Book        string
	Chapter     int64
	Verse       int64
	Content     string
}

func (q *Queries) CreateVerse(ctx context.Context, arg CreateVerseParams) (Verse, error) {
	row := q.db.QueryRowContext(ctx, createVerse,
		arg.Translation,
		arg.Book,
		arg.Chapter,
		arg.Verse,
		arg.Content,
	)
	var i Verse
	err := row.Scan(
		&i.ID,
		&i.Translation,
		&i.Book,
		&i.Chapter,
		&i.Verse,
		&i.Content,
	)
	return i, err
}

const getBook = `-- name: GetBook :many
SELECT id, translation, book, chapter, verse, content FROM verses
WHERE translation = ?
AND book = ?
`

type GetBookParams struct {
	Translation string
	Book        string
}

func (q *Queries) GetBook(ctx context.Context, arg GetBookParams) ([]Verse, error) {
	rows, err := q.db.QueryContext(ctx, getBook, arg.Translation, arg.Book)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Verse
	for rows.Next() {
		var i Verse
		if err := rows.Scan(
			&i.ID,
			&i.Translation,
			&i.Book,
			&i.Chapter,
			&i.Verse,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChapter = `-- name: GetChapter :many
SELECT id, translation, book, chapter, verse, content FROM verses
WHERE translation = ?
AND book = ?
AND chapter = ?
`

type GetChapterParams struct {
	Translation string
	Book        string
	Chapter     int64
}

func (q *Queries) GetChapter(ctx context.Context, arg GetChapterParams) ([]Verse, error) {
	rows, err := q.db.QueryContext(ctx, getChapter, arg.Translation, arg.Book, arg.Chapter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Verse
	for rows.Next() {
		var i Verse
		if err := rows.Scan(
			&i.ID,
			&i.Translation,
			&i.Book,
			&i.Chapter,
			&i.Verse,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerse = `-- name: GetVerse :one
SELECT id, translation, book, chapter, verse, content FROM verses
WHERE translation = ?
AND book = ?
AND chapter = ?
AND verse = ?
LIMIT 1
`

type GetVerseParams struct {
	Translation string
	Book        string
	Chapter     int64
	Verse       int64
}

func (q *Queries) GetVerse(ctx context.Context, arg GetVerseParams) (Verse, error) {
	row := q.db.QueryRowContext(ctx, getVerse,
		arg.Translation,
		arg.Book,
		arg.Chapter,
		arg.Verse,
	)
	var i Verse
	err := row.Scan(
		&i.ID,
		&i.Translation,
		&i.Book,
		&i.Chapter,
		&i.Verse,
		&i.Content,
	)
	return i, err
}
